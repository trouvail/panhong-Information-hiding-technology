# 信息隐藏技术第五次实验 —— `二值图像隐藏法`

> **学号：2013921  
姓名：周延霖  
专业：信息安全**






## 一、二值图像信息隐藏
---




### **1. 二值图像**

二值图像是由黑白像素分布构成图像





### **2. 通常方法**


处理二值图像的一般方法是利用图像区域中黑色像素的个数对秘密信息进行编码







## 二、隐藏思路
---





### **1. 思路一**




> (1)嵌入


- 需要将一个二值图像分成 `L(m)` 个矩形图像区域 `Bi` ，若其中黑色像素的个数大于1/2，则表示嵌入 0 ；如果白色像素的个数大于一半，则表示嵌入 1
- 当需要嵌入的比特与所选区域的黑白像素的比例不一致时，为了达到希望的像素关系，则改一些像素颜色
- 遵循一定的规则，并不引起感观察觉
- 应在黑白区域边缘进行


> (2)需注意的细节



- 考虑有一定的冗余度
- 确定两个阈值 `R1 > 50%` 和 `R0 < 50%` ，一个健壮性参数 λ 。隐藏 0 时，该块的黑色像素的个数应属于 `[R1 , R1 + λ]` 隐藏 1 时，该块的黑色像素的个数应属于 `[R0 - λ , R0]`
- 若为了适应所嵌入的比特，目标块必须修改太多的像素，就将该块设为无效
- 将无效块中的像素进行少量的修改，使得其中黑色像素的百分比大于 `R1 + 3λ` ，或者小于 `R0 - 3λ` 



> (3)提取



- 判断每一个图像块黑色像素的百分比，如果大于 `R1 + 3λ` ，或者小于 `R0 - 3λ` ，则跳过类似这样的无效块
- 若在 `[R1 , R1 + λ]` 或者 `[R0 - λ , R0]` 的范围内，则正确提取出秘密信息 0 或 1




### **2. 思路二**


使用游程编码的方法，如下图所示：


![](https://i.imgtg.com/2023/04/19/ugp5t.png)



编码：`< a0, 3 > < a1, 5 > < a2, 4 > < a3, 2 > < a4, 1 >`


> (1)嵌入


- 修改二值图像的游程长度
- 若秘密信息位是 0 ，则修改该游程长度为偶数
- 若为 1 ，则修改游程长度为奇数
- 若秘密信息的取值与游程长度的奇偶性相匹配，则不改变游程长度





> (2)提取

根据游程长度奇偶性提取出秘密信息






## 三、实验代码
---



使用 `MATLAB` 实现了第二种方法，即 `2.2.` 中的利用游程编码的方法，用 decode.m 实现秘密信息嵌入，用 encode.m 实现秘密信息提取，嵌入时用到了 str2bit 和 Vector2Matrix 两个函数做待隐藏信息的编码处理，提取时用到了 bit2str 函数解码比特串为正常字符串



### **1. encode.m**


```MATLAB
clear all;
oi=imread('载体图片.bmp');%打开载体图像
[row col]=size(oi);
oi=oi(:);%将矩阵竖向排开变成一列
len=size(oi);

%统计游程长度
i=1;
j=1;
while i<len(1)
    or=oi(i,1);
    count=1;
    while (i<len(1)&&oi(i+1,1)==or)
        i=i+1;
        count=count+1;
    end
    RLE(j)=count;
    j=j+1;
    i=i+1;
end
if i==len(1)
    RLE(j)=1;
end
RLE=RLE';

%将秘密信息转化为二进制
msgfid=fopen('隐藏信息.txt','r');%打开秘密文件
[msg,msgcount]=fread(msgfid);
fclose(msgfid);
msg = str2bit(msg);
msg = msg';
msgcount=msgcount*8;

%利用游程编码的方法将秘密信息嵌入图片
for l=1:msgcount
    modpoint=0;
    for x=1:2*l
        modpoint=modpoint+RLE(x,1);
    end
    if msg(l,1)==0
        if ((mod(RLE(2*l,1),2)~=0)&&(RLE(2*1+1,1)~=1))
            oi(modpoint+1,1)=mod((oi(modpoint+1,1)+1),2);
        end
    else
        if ((mod(RLE(2*l,1),2)==0)&&(RLE(2*1+1,1)~=1))
            oi(modpoint+1,1)=mod((oi(modpoint+1,1)+1),2);
        end
    end
end

%存储处理后的图片
m1=Vector2Matrix(oi,row);%将数组转换成为二维矩阵
imwrite(m1,'载体图片_隐藏信息.bmp');

%显示处理前后的图片
figure;
imshow('载体图片.bmp');
title('处理前');
figure;
imshow('载体图片_隐藏信息.bmp');
title('处理后');
```


将待隐藏信息保存在 `隐藏信息.txt` 中，取出信息编码为二进制比特串才能进行隐藏

为了方便处理，先将图片信息存到一维数组中对其游程的奇偶性做更改，再转换为二维数组存回图片，完成信息隐藏




### **2. decode.m**



```MATLAB
clear all;
oi=imread('载体图片_隐藏信息.bmp'); %打开携密图像
[row col]=size(oi);
oi=oi(:);%将矩阵竖向排开变成一列
len=size(oi);

%统计游程长度
i=1;
j=1;
while i<len(1)
    or=oi(i,1);
    count=1;
    while (i<len(1)&&oi(i+1,1)==or)
        i=i+1;
        count=count+1;
    end
    RLE(j)=count;
    j=j+1;
    i=i+1;
end
if i==len(1)
    RLE(j)=1;
end
RLE=RLE';

%将游程信息提取为二进制比特串
msgcount=256;
for i=1:msgcount
    msg(i,1)=0;
end
for l=1:msgcount
    if mod(RLE((2*l),1),2)==0 
        msg(l,1)=0; %如果游程的值为偶数，表示隐藏的信息为0
    else
        msg(l,1)=1; %如果游程的值为奇数，表示隐藏的信息为1
    end
end

%将比特串解码为字符串后保存到文件
out=bit2str(msg);
fid=fopen('提取信息.txt', 'wt');
fwrite(fid, out);
fclose(fid);
```



提取与隐藏类似，但只需要对隐藏信息的载体图片的游程进行统计以获得相应的二进制比特串，然后再解码为正常的字符串




### **3. 字符串处理函数**



见文件 `str2bit.m` `Vector2Matrix.m` `bit2str.m` ，分别用来：

- 将字符串编码为比特串
- 将数组转换成为二维矩阵
- 将比特串解码为字符串





## 四、实验结果
---




### **1. 原始图片**


> 载体图片.bmp

![](https://i.imgtg.com/2023/04/19/uggYX.png)



### **2. 待隐藏秘密信息**


> 隐藏信息.txt
```txt
2013921-hamlin-zhou
```



### **3. 嵌入秘密信息后的图片**


> 载体图片_隐藏信息.bmp

![](https://i.imgtg.com/2023/04/19/ugypi.png)




### **4. 从图片提取的秘密信息**


> 提取信息.txt


```txt
2013921-hamlin-zhou    
```




## 五、总结与展望
---

本次实验利用 `MATLAB` 和对将秘密图像或文本转化为二进制码流，进一步利用黑白像素包含的区域冗余度进行隐藏，注意控制隐藏对象的大小和容量与秘密信息的匹配，注意图像行列的动态变化，需要发送者和接收者提前进行提取和隐藏方法的沟通



通过对所学到的理论知识进行相应的应用，对`MATLAB`的应用也更加的熟练，最后期待自己未来更好的发展，`心想事成、万事胜意、未来可期`














